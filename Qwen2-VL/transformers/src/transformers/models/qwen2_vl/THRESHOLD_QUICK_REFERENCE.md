# 阈值 [3, 2] 速查卡

## 🎯 一句话解释

**[3, 2] 是两个选择阈值**，用于决定哪些图像区域用 28px 补丁处理、哪些用 56px 补丁处理：
- 如果区域复杂度 < 3 → 用 28px 补丁
- 如果区域复杂度 < 2 → 用 56px 补丁

---

## 📊 直观图解

```
原始图像
   ↓
计算每个补丁的复杂度(熵值)
   ↓
   ├─ 复杂度低(< 2)  → 用最粗的 56px 补丁 ■■■■
   ├─ 复杂度中(2-3)  → 用中等的 28px 补丁  ■■
   └─ 复杂度高(> 3)  → 用最细的 14px 补丁  ■

结果: 自适应选择最优补丁大小
```

---

## 🔢 数字解读

### 列表中的两个数字

```
thresholds = [3, 2]
             ↓  ↓
         28px 56px
         阈值 阈值
```

| 位置 | 数值 | 含义 | 补丁尺度 |
|------|------|------|----------|
| 第1个 | 3 | 28像素补丁的选择线 | 中等粒度 |
| 第2个 | 2 | 56像素补丁的选择线 | 粗粒度 |

### 阈值规律

```
28px阈值 > 56px阈值
   3    >    2
   
这是必须的，因为：
- 阈值越高，该尺度的补丁越多被保留
- 尺度越大(56 > 28)，应该处理越简单的区域
- 所以需要 threshold_28 > threshold_56
```

---

## 🧠 工作原理

### 三层补丁架构

```
层数   补丁尺度  默认行为         控制参数
───────────────────────────────────────
1     14 像素   总是保留         -
2     28 像素   有条件保留       阈值 3
3     56 像素   严格筛选         阈值 2
```

### 决策流程

```
对每个图像位置:

    计算复杂度 D
         │
         ├─ D < 2? 
         │  ├─ YES → 用 56px 补丁 (最粗, 快速)
         │  └─ NO  ↓
         │
         ├─ D < 3?
         │  ├─ YES → 用 28px 补丁 (中等)
         │  └─ NO  ↓
         │
         └─ 用 14px 补丁 (最细, 精细)
```

---

## 📈 效果对比

### 不同复杂度区域的处理

```
区域类型        复杂度(D)  28px<=3?  56px<=2?  选择
────────────────────────────────────────────────
单色背景          0.5       ✓        ✓       56px ⏱️ 快
单一纹理          1.8       ✓        ✓       56px ⏱️ 快
混合纹理          2.5       ✓        ✗       28px ⚖️ 中
物体边界          3.5       ✗        ✗       14px 📊 精
细节密集          4.5       ✗        ✗       14px 📊 精
```

---

## 💡 直观理解

### 用"质量"类比

```
想象有三种扫描分辨率:
- 14px: 高清扫描 (贵)
- 28px: 标清扫描 (中等)
- 56px: 低清扫描 (便宜)

阈值决定了使用策略:
- 高清区域 (复杂图案)     → 用高清扫描
- 普通区域 (混合纹理)     → 用标清扫描  
- 模糊区域 (单色背景)     → 用低清扫描

省钱又保证质量!
```

---

## 🔄 代码映射

```
阈值参数 → 代码执行位置

[3, 2]
 ↓
visualize_patches.py:
  --thresholds 3 2
    ↓
PatchTokenizer(thresholds=[3, 2])
    ↓
entropy_utils.py - select_patches_by_threshold():
    ↓
masks[28] = (entropy < 3.0)   # 第一个阈值
masks[56] = (entropy < 2.0)   # 第二个阈值
    ↓
result: 掩码 (指示每个补丁的尺度)
```

---

## 🎮 快速调整

### 想要更快？

```
当前: --thresholds 3 2
改为: --thresholds 4 3  或 5 4
原因: 更高的阈值 → 更多粗粒度补丁 → 更快
```

### 想要更精准？

```
当前: --thresholds 3 2
改为: --thresholds 2 1  或 1.5 0.5
原因: 更低的阈值 → 更多细粒度补丁 → 更精准
```

---

## 📊 消耗对比

### 计算成本模型

```
假设 100 个补丁位置

配置      14px  28px  56px   总成本  速度
[3,2]     70    20    10      80    1.0x ✓
[2,1]     80    15    5       93    0.9x
[4,3]     60    25    15      65    1.1x
```

计算: `成本 = 14px数×1 + 28px数×0.25 + 56px数×0.0625`

---

## ✅ 验证方法

### 检查热力图生成的文件

```
importance_map_scale_14.png  → 高复杂度
importance_map_scale_28.png  → 中复杂度
importance_map_scale_56.png  → 低复杂度

特征:
- 阈值越低 → 对应热力图越"黑"(更多被舍弃)
- 阈值越高 → 对应热力图越"亮"(更多被保留)
```

---

## 🎓 核心公式

```
最终补丁选择规则:

if entropy < thresholds[0]:  # 3
    use 28px patch
elif entropy < thresholds[1]:  # 2
    use 56px patch
else:
    use 14px patch (fallback)

简化:
D < 2 ? 56px : (D < 3 ? 28px : 14px)
```

---

## 📝 使用示例

### 默认均衡

```bash
python visualize_patches.py image.jpg
# 等价于:
python visualize_patches.py image.jpg --thresholds 3 2
```

### 精度优先

```bash
python visualize_patches.py image.jpg --thresholds 2 1
# 更多使用细粒度补丁，精度更高
```

### 速度优先

```bash
python visualize_patches.py image.jpg --thresholds 4 3
# 更多使用粗粒度补丁，速度更快
```

---

## 🚀 性能特性

```
阈值配置    精度    速度    内存    推荐指数
[1.5, 0.5]  ★★★★★  ★        ★★★★★  研究用
[2, 1]      ★★★★   ★★       ★★★★   精度优先
[3, 2]      ★★★    ★★★      ★★★    通用推荐
[4, 3]      ★★     ★★★★     ★★     速度优先
[5, 4]      ★      ★★★★★    ★      实时优先
```

---

## 💬 常见问答

**Q: 为什么第一个数字总是大于第二个？**

A: 因为 28px 是中等粒度，56px 是粗粒度。中等的补丁应该处理更多的区域，所以阈值要更高。

**Q: 能不能用 [2, 2]？**

A: 不行。如果两个相同，就无法区分哪些区域用 28px，哪些用 56px。必须 threshold[0] > threshold[1]。

**Q: 阈值可以是小数吗？**

A: 可以！例如 [2.5, 1.5] 也是有效的。

**Q: 改变阈值会改变输出吗？**

A: 会改变补丁的分布，但最终处理的都是同一张图像。只是处理方式（补丁尺度）不同。

